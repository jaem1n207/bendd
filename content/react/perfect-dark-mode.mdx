---
title: 'React 다크 모드 완벽 구현 가이드'
summary: '사용자 친화적인 다크 모드 만들기'
description: 'React에서 useSyncExternalStore와 zustand를 활용해 깜빡임 없는 다크 모드를 구현하는 방법을 알아봅니다. 시스템 테마 감지부터 접근성 고려사항까지, 실무에서 바로 사용할 수 있는 완성도 높은 다크 모드를 만들어보세요.'
category: 'react'
publishedAt: '2024-04-30'
---

다크 모드를 제대로 구현하려면 생각할 게 많아요. 사용자 시스템 설정을 감지하고, 깜빡임 없이 테마를 전환하고, 접근성까지 고려해야 하죠. 하지만 차근차근 따라하다 보면 생각보다 어렵지 않답니다!

<Callout type="info">
이 가이드에서는 실무에서 바로 사용할 수 있는 완성도 높은 다크 모드 구현 방법을 다룹니다. 복잡한 이론보다는 실제 동작하는 코드에 집중해서 설명할게요.
</Callout>

<Steps>

<div>

## 시스템 테마 설정 감지하기

사용자가 OS에서 다크 모드로 설정해 놓았다면, 우리 웹앱도 다크 모드로 표시되는 게 자연스럽겠죠? `prefers-color-scheme` 미디어 쿼리로 사용자의 시스템 테마 설정을 감지할 수 있어요.

핵심은 **`useSyncExternalStore` 훅**을 사용하는 거예요. 이 훅이 하는 일을 간단히 설명하면:

1. 외부 저장소(여기서는 시스템 테마 설정)의 변경사항을 실시간으로 감지
2. React 18의 동시성 렌더링에서 UI 일관성 보장 (Tearing 방지)

```tsx title="시스템 다크 모드 감지 훅" {19-23}
const MEDIA = '(prefers-color-scheme: dark)';

const subscribeSystemDark = (onStoreChange: () => void) => {
  const mediaQuery = window.matchMedia(MEDIA);
  mediaQuery.addEventListener('change', onStoreChange);

  return () => mediaQuery.removeEventListener('change', onStoreChange);
};

const getSystemDarkSnapshot = () => {
  return window.matchMedia(MEDIA).matches;
};

const getServerSnapshot = () => {
  return undefined;
};

export const useSystemDark = () => {
  return useSyncExternalStore(
    subscribeSystemDark,
    getSystemDarkSnapshot,
    getServerSnapshot
  );
};
```

<Callout type="info" emoji="💡">
`useSyncExternalStore`에 대해 더 자세히 알고 싶다면 [JSer.dev의 블로그](http://jser.dev/2023-08-02-usesyncexternalstore)를 참고해보세요!
</Callout>

</div>

<div>

## 다크 모드 설정 관리하기

이제 시스템 테마를 감지했으니, 사용자가 직접 테마를 선택할 수 있는 기능도 만들어야겠죠. 사용자는 다음 세 가지 중 하나를 선택할 수 있어야 해요:

- **시스템 설정 따르기** (기본값)
- **라이트 모드 고정**
- **다크 모드 고정**

```tsx title="다크 모드 설정 훅" {17-20,22-26}
import {
  isDarkMode,
  mergeDefaultOptions,
  type Options,
  type Theme,
} from '~/entities/theme/lib';
import { useSystemDark } from '~/entities/theme/model/use-system-dark';

export const useDark = (options?: Options) => {
  const { storageKey } = mergeDefaultOptions(options);

  const [theme, setTheme] = useLocalStorageState<Theme>(storageKey, {
    defaultValue: 'system',
  });
  const isSystemDark = useSystemDark();

  const isDark = useMemo(
    () => isDarkMode(theme, isSystemDark),
    [theme, isSystemDark]
  );

  const toggleDark = () => {
    theme === 'system'
      ? setTheme(isSystemDark ? 'light' : 'dark')
      : setTheme('system');
  };

  useEffect(() => {
    document.documentElement.classList.toggle('dark', isDark);

    if (
      (theme === 'dark' && isSystemDark) ||
      (theme === 'light' && !isSystemDark)
    ) {
      setTheme('system');
    }
  }, [isDark, isSystemDark, setTheme, theme]);

  return { isDark, toggleDark };
};
```

<Callout type="warning">
이 훅은 한 가지 문제가 있어요. 여러 컴포넌트에서 동시에 사용하면 상태가 동기화되지 않는 현상이 발생할 수 있거든요. 이 문제는 zustand 같은 전역 상태 관리 라이브러리로 해결할 수 있어요!
</Callout>

</div>

<div>

## 테마 커스터마이징

다크/라이트 모드 외에도 사용자가 원하는 대로 테마를 꾸밀 수 있다면 더 좋겠죠? 색상 팔레트나 모서리 둥긂 정도 같은 것들을 커스터마이징할 수 있게 해봅시다.

```tsx title="테마 커스터마이저"
export const ThemeCustomizer = () => {
  const [config, setConfig] = useLocalStorageState<Config>('config', {
    defaultValue: DEFAULT_CONFIG,
  });

  const handleConfigChange = (key: keyof Config, value: Config[keyof Config]) => {
    if (typeof value === 'string' && key === 'theme') {  // [!code focus]
      document.body.classList.remove(`theme-${config?.theme}`);  // [!code focus]
      document.body.classList.add(`theme-${value}`);  // [!code focus]
    } else if (typeof value === 'number' && key === 'radius') {  // [!code focus]
      document.body.style.setProperty('--radius', `${value}rem`);  // [!code focus]
    }  // [!code focus]

    if (config === undefined) {
      return setConfig(DEFAULT_CONFIG);
    }
    setConfig({ ...config, [key]: value });
  };
  // ... 나머지 렌더링 로직
};
```

설정이 변경될 때마다 DOM에 직접 클래스나 스타일을 적용해서 즉시 반영되도록 했어요. 사용자가 실시간으로 변화를 볼 수 있어서 훨씬 좋은 경험을 제공할 수 있답니다!

</div>

<div>

## 깜빡임 없는 테마 로딩

다크 모드를 구현할 때 가장 신경 쓰이는 부분이 바로 **페이지 로딩 시 깜빡임** 문제예요. 사용자가 다크 모드로 설정해 놓았는데, 페이지가 처음엔 라이트 모드로 잠깐 보였다가 다크 모드로 바뀐다면... 상당히 어색하겠죠? 😅

이 문제를 해결하는 핵심은 **React가 렌더링되기 전에 미리 테마를 설정**하는 것이에요.

<MagicMove
  lang="typescript"
  codeSnippets={[
    {
      title: "1단계: 기본 HTML 구조",
      description: "아직 깜빡임 문제가 있는 상태",
      content: `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bendd</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="/bundle.js"></script>
  </body>
</html>`
    },
    {
      title: "2단계: 테마 동기화 스크립트 추가",
      description: "렌더링 전에 테마를 미리 설정",
      content: `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Bendd</title>
    <style>
      html.dark {
        color-scheme: dark;
      }
    </style>
    <script type="module" src="/dist/themeSync.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script src="/bundle.js"></script>
  </body>
</html>`
    },
    {
      title: "3단계: themeSync.js 구현",
      description: "localStorage와 시스템 설정을 확인해서 즉시 테마 적용",
      content: `// /dist/themeSync.js
var isSystemDark = window.matchMedia && 
  window.matchMedia('(prefers-color-scheme: dark)').matches;
var theme = localStorage.getItem('theme') || 'system';

// 다크 모드 조건 확인 후 클래스 적용
if (theme === 'dark' || (isSystemDark && theme !== 'light')) {
  document.documentElement.classList.add('dark');
}

// 추가 테마 설정도 함께 적용
var configItem = localStorage.getItem('config');
var { theme: colorTheme = 'neutral', radius = 0.5 } = 
  configItem ? JSON.parse(configItem) : {};
document.body.classList.add(\`theme-\${colorTheme}\`);
document.body.style.setProperty('--radius', \`\${radius}rem\`);`
    }
  ]}
/>

<Callout type="info" emoji="🎯">
**핵심 아이디어**: 브라우저가 스크립트 태그를 만나면 실행이 완료될 때까지 렌더링을 중단해요. 이 특성을 이용해서 테마를 미리 설정하고 나서 렌더링하도록 하는 거죠!
</Callout>

이제 사용자는 깜빡임 없이 처음부터 올바른 테마로 설정된 화면을 볼 수 있어요! 🎉

</div>


<div>

## 테마 전환 애니메이션과 접근성

테마가 바뀔 때 부드러운 애니메이션이 있으면 더 좋은 사용자 경험을 만들 수 있어요. 하지만 **접근성**도 함께 고려해야 합니다!

```tsx title="테마 전환 애니메이션"
<Button className="transition-colors">
  테마 변경 버튼
</Button>

<button type="button" onClick={toggleTheme} className="flex">
  <div className="i-lucide-sun scale-100 dark:scale-0 transition-transform duration-300 rotate-0 dark:-rotate-90" />
  <div className="i-lucide-moon absolute scale-0 dark:scale-100 transition-transform duration-300 rotate-90 dark:rotate-0" />
  <span className="sr-only">Toggle theme</span>
</button>
```

<Callout type="warning" emoji="⚠️">
**접근성 주의사항**: 애니메이션은 광과민성 간질이나 전정기관 장애가 있는 사용자에게 문제가 될 수 있어요. `prefers-reduced-motion` 미디어 쿼리로 사용자의 "애니메이션 줄이기" 설정을 꼭 확인해주세요!
</Callout>

### 애니메이션 줄이기 설정 감지

사용자의 OS 설정을 존중하는 것이 중요해요. 다행히 `prefers-reduced-motion` 미디어 쿼리로 쉽게 확인할 수 있습니다.

```tsx title="애니메이션 줄이기 감지 훅"
const QUERY = '(prefers-reduced-motion: reduce)';

const subscribePrefersReducedMotion = (onStoreChange: () => void) => {
  const mediaQuery = window.matchMedia(QUERY);
  mediaQuery.addEventListener('change', onStoreChange);

  return () => mediaQuery.removeEventListener('change', onStoreChange);
};

const getPrefersReducedMotionSnapshot = () => {
  return window.matchMedia(QUERY).matches;
};

const getServerSnapshot = () => {
  return undefined;
};

export const usePrefersReducedMotion = () => {
  return useSyncExternalStore(
    subscribePrefersReducedMotion,
    getPrefersReducedMotionSnapshot,
    getServerSnapshot
  );
};
```

이제 JS 애니메이션도 쉽게 제어할 수 있어요:

```tsx title="조건부 애니메이션 적용" {2-3}
export const Sidebar = ({ isOpen }) => {
  const shouldReduceMotion = usePrefersReducedMotion();
  const closedX = shouldReduceMotion ? 0 : '-100%';

  return (
    <motion.div
      animate={{
        opacity: isOpen ? 1 : 0,
        x: isOpen ? 0 : closedX,
      }}
    />
  );
};
```

</div>

<div>

## 다크모드 설정 훅 리팩토링

앞서 만든 `useDark` 훅에는 한 가지 문제가 있어요. 여러 컴포넌트에서 동시에 사용하면 상태가 동기화되지 않는 현상이 발생할 수 있거든요.

### 문제 상황

```tsx title="문제가 되는 사용 패턴"
// theme-customizer.tsx
export const ThemeCustomizer = () => {
  const { isDark } = useDark();
  // 이 컴포넌트의 isDark 상태
};

// appearance-switch.tsx  
export const AppearanceSwitch = () => {
  const { toggleTheme } = useDark();
  // 이 컴포넌트에서 toggleTheme을 호출해도
  // ThemeCustomizer의 isDark가 업데이트되지 않을 수 있음!
};
```

### Zustand로 해결하기

이런 문제는 **전역 상태 관리**로 해결할 수 있어요. zustand를 사용하면 간단하면서도 효과적으로 해결할 수 있습니다.

```tsx title="Zustand 테마 스토어" /create/
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface ThemeState {
  theme: Theme;
  isSystemDark: boolean;
  toggleTheme: () => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      theme: 'system',
      isSystemDark: false,
      toggleTheme: () => {
        const { theme, isSystemDark } = get();
        if (theme === 'system') {
          set({ theme: isSystemDark ? 'light' : 'dark' });
        } else {
          set({ theme: 'system' });
        }
      },
    }),
    {
      name: 'theme',
    }
  )
);
```

이제 개선된 `useDark` 훅을 만들어보세요:

```tsx title="개선된 useDark 훅" /useThemeStore/
export const useDark = () => {
  const theme = useThemeStore(state => state.theme);
  const toggleTheme = useThemeStore(state => state.toggleTheme);
  const isSystemDark = useSystemDark();

  useEffect(() => {
    useThemeStore.setState({ isSystemDark });
  }, [isSystemDark]);

  const isDark = useMemo(
    () => isDarkMode(theme, isSystemDark),
    [theme, isSystemDark]
  );

  useEffect(() => {
    document.documentElement.classList.toggle('dark', isDark);
    if (
      (theme === 'dark' && isSystemDark) ||
      (theme === 'light' && !isSystemDark)
    ) {
      toggleTheme();
    }
  }, [isDark, theme, isSystemDark, toggleTheme]);

  return { isDark, toggleTheme };
};
```

<Callout type="info" emoji="✨">
**왜 zustand?** React Context API보다 더 간결한 코드로 작성할 수 있어요. Context API의 불필요한 리렌더링 문제도 해결됩니다. 성능 비교와 올바른 사용법이 궁금하다면 [Zustand vs Context API: 올바른 선택과 사용법](zustand-vs-context-performance)을 확인해보세요!
</Callout>

</div>

</Steps>

## 마무리하며

React 다크 모드 구현, 생각보다 신경 쓸 게 많았죠? 하지만 이렇게 차근차근 구현하면 사용자가 정말 만족할 만한 다크 모드를 만들 수 있어요!

### 구현한 기능들

- ✅ 시스템 테마 설정 자동 감지
- ✅ 깜빡임 없는 테마 로딩
- ✅ 부드러운 테마 전환 애니메이션  
- ✅ 접근성 고려 (prefers-reduced-motion)
- ✅ 전역 상태 관리로 안정적인 상태 동기화
- ✅ 테마 커스터마이징 지원

### 추가로 알아보면 좋은 내용

실무에서 다크 모드를 더 효율적으로 구현하고 싶다면 이런 내용들도 살펴보세요:

<Callout type="info" emoji="📚">
- **성능 최적화**: [스크립트 로딩 최적화 전략](script-loading-optimization)에서 조건부 스크립트 로딩 방법을 알아보세요
- **상태 관리**: [Zustand vs Context API: 올바른 선택과 사용법](zustand-vs-context-performance)에서 더 자세한 가이드를 확인하세요
</Callout>

사이드 프로젝트에서 이런저런 시도를 해보면서 많은 걸 배우는 것 같아요. 막히더라도 이미 잘 구현되어 있는 라이브러리 코드를 참고하면 되니까 부담 없이 도전할 수 있기도 하니까요! 그런 점이 사이드 프로젝트를 끊을 수 없는 이유인 것 같습니다.

## 참고 자료

- [Accessible Animations in React](https://www.joshwcomeau.com/react/prefers-reduced-motion/)
- [useSyncExternalStore 상세 가이드](http://jser.dev/2023-08-02-usesyncexternalstore)
- [Zustand 공식 문서](https://docs.pmnd.rs/zustand)
