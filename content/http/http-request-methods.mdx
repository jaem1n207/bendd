---
title: '9가지 HTTP 요청 메서드 특징'
summary: '각 HTTP 요청 메서드 유형과 특징 소개'
description: 'HTTP 요청 메서드는 서버에 수행하길 원하는 행동을 나타냅니다. 이번 글에서는 9가지 HTTP 요청 메서드를 살펴보고 각 특징에 대해 이야기합니다.'
category: 'http'
publishedAt: '2024-05-13'
---

API를 개발하다 보면 "이 기능에는 어떤 HTTP 메서드를 써야 하지?"라는 고민을 하게 돼요. 데이터를 가져올 때는 GET, 새로 만들 때는 POST... 그런데 정말 이게 다일까요?

HTTP에는 총 9가지 메서드가 있고, 각각 고유한 목적과 특성을 가지고 있어요. 올바른 메서드를 선택하면 API가 더 직관적이고 안전해져요.

## HTTP 메서드의 3가지 핵심 특성

HTTP 메서드를 이해하려면 3가지 특성을 알아야 해요:

<Steps>

### Safe (안전성)
서버 상태를 변경하지 않는 읽기 전용 메서드예요. 몇 번을 호출해도 서버에 부작용이 없어요.

### Idempotent (멱등성) 
같은 요청을 여러 번 해도 결과가 동일한 특성이에요. 네트워크 문제로 재시도할 때 안전해요.

### Cacheable (캐시 가능성)
응답을 캐시해서 성능을 향상시킬 수 있는지를 나타내요.

</Steps>

## 한눈에 보는 HTTP 메서드 비교

| 메서드 | Safe | Idempotent | Cacheable | 주요 용도 | 사용 빈도 |
|--------|------|------------|-----------|-----------|-----------|
| **GET** | ✅ | ✅ | ✅ | 데이터 조회 | ⭐⭐⭐⭐⭐ |
| **POST** | ❌ | ❌ | 조건부 | 데이터 생성, 복잡한 요청 | ⭐⭐⭐⭐⭐ |
| **PUT** | ❌ | ✅ | ❌ | 데이터 전체 교체/생성 | ⭐⭐⭐ |
| **PATCH** | ❌ | ❌ | ❌ | 데이터 부분 수정 | ⭐⭐⭐ |
| **DELETE** | ❌ | ✅ | ❌ | 데이터 삭제 | ⭐⭐⭐ |
| **HEAD** | ✅ | ✅ | ✅ | 헤더만 조회 | ⭐⭐ |
| **OPTIONS** | ✅ | ✅ | ❌ | 허용된 메서드 확인 | ⭐⭐ |
| **CONNECT** | ❌ | ❌ | ❌ | 프록시 터널링 | ⭐ |
| **TRACE** | ✅ | ✅ | ❌ | 디버깅용 (보안 위험) | ⭐ |

## 1. GET: 데이터를 가져와줘

가장 기본적이고 많이 사용하는 메서드예요. 웹페이지를 열거나 API에서 데이터를 조회할 때 사용해요.

```http title="사용자 정보 조회하기"
GET /api/users/123
Accept: application/json
```

```json title="응답 예시"
{
  "id": 123,
  "name": "이재민",
  "email": "dev@example.com"
}
```

**언제 사용하나요?**
- 사용자 목록 조회: `GET /api/users`
- 특정 게시글 보기: `GET /api/posts/456`
- 검색 결과 가져오기: `GET /api/search?q=javascript`

✅ **Safe** - 서버 상태를 변경하지 않아요  
✅ **Idempotent** - 몇 번을 호출해도 같은 결과  
✅ **Cacheable** - 브라우저가 결과를 캐시할 수 있어요

## 2. POST: 새로운 데이터를 만들어줘

서버에 새로운 데이터를 생성하거나 복잡한 요청을 처리할 때 사용하는 만능 메서드예요.

```http title="새 사용자 회원가입"
POST /api/users
Content-Type: application/json

{
  "name": "이재민",
  "email": "dev@example.com",
  "password": "securePassword123"
}
```

```json title="응답 예시 (201 Created)" {2}
{
  "id": 124,  // [!code highlight]
  "name": "이재민",
  "email": "dev@example.com",
  "createdAt": "2024-05-13T10:30:00Z"
}
```

**언제 사용하나요?**
- 회원가입: `POST /api/users`
- 게시글 작성: `POST /api/posts`
- 파일 업로드: `POST /api/files`
- 복잡한 검색: `POST /api/search` (검색 조건이 너무 많을 때)

❌ **Safe** - 서버 상태를 변경해요  
❌ **Idempotent** - 같은 요청을 다시 보내면 중복 생성될 수 있어요  
❗ **Cacheable** - 조건부로 캐시 가능해요

<Callout type="info">
**POST 캐싱이 가능한 경우**

POST 응답도 적절한 Cache-Control 헤더가 있으면 캐시할 수 있어요. 하지만 실무에서는 거의 캐시하지 않아요. 대신 GET으로 조회할 수 있는 API를 따로 만드는 것이 일반적이에요.
</Callout>

## 3. PUT: 전체를 이것으로 바꿔줘

리소스 전체를 새로운 내용으로 교체할 때 사용해요. 파일을 덮어쓰는 것과 비슷한 개념이에요.

```http title="사용자 정보 전체 업데이트"
PUT /api/users/123
Content-Type: application/json

{
  "name": "이재민",
  "email": "newdev@example.com",
  "phone": "010-9876-5432"
}
```

**언제 사용하나요?**
- 사용자 프로필 전체 수정: `PUT /api/users/123`
- 설정 파일 교체: `PUT /api/config`
- 문서 전체 업데이트: `PUT /api/documents/456`

**주의할 점**
- 보내지 않은 필드는 삭제될 수 있어요
- 전체 데이터를 알고 있을 때만 사용하세요

❌ **Safe** - 서버 상태를 변경해요  
✅ **Idempotent** - 같은 요청을 여러 번 해도 결과가 동일해요  
❌ **Cacheable** - 캐시하지 않아요

## 4. PATCH: 이 부분만 살짝 바꿔줘

리소스의 일부분만 수정할 때 사용해요. PUT과 달리 변경하고 싶은 필드만 보내면 돼요.

```http title="이메일만 변경하기"
PATCH /api/users/123
Content-Type: application/json

{
  "email": "updated@example.com"  // [!code highlight]
}
```

**언제 사용하나요?**
- 비밀번호만 변경: `PATCH /api/users/123`
- 게시글 상태만 변경: `PATCH /api/posts/456`
- 일부 설정만 수정: `PATCH /api/config`

**PUT vs PATCH 비교**
- PUT: 전체 교체 → 모든 필드 필요
- PATCH: 부분 수정 → 변경할 필드만

❌ **Safe** - 서버 상태를 변경해요  
❌ **Idempotent** - 구현 방식에 따라 다를 수 있어요  
❌ **Cacheable** - 캐시하지 않아요

<Callout type="info">
**더 자세한 PUT vs PATCH 비교**

PUT과 PATCH의 차이점과 멱등성에 대해 더 자세히 알고 싶다면 [PUT과 PATCH의 차이점과 멱등성](difference-between-put-patch) 글을 참고해보세요!
</Callout>

## 5. DELETE: 이거 삭제해줘

서버에서 데이터를 삭제할 때 사용해요. 휴지통에 버리는 것과 같은 개념이에요.

```http title="사용자 계정 삭제"
DELETE /api/users/123
```

```http title="게시글 삭제"
DELETE /api/posts/456
```

**언제 사용하나요?**
- 계정 탈퇴: `DELETE /api/users/123`
- 게시글 삭제: `DELETE /api/posts/456`
- 파일 삭제: `DELETE /api/files/789`

**주의할 점**
- 한 번 삭제하면 되돌리기 어려워요
- 실제로는 soft delete(상태만 변경)를 많이 사용해요
- 권한 검증을 꼼꼼히 해야 해요

❌ **Safe** - 서버 상태를 변경해요  
✅ **Idempotent** - 이미 없는 걸 또 삭제해도 결과는 동일해요  
❌ **Cacheable** - 캐시하지 않아요

## 6. HEAD: 헤더만 살짝 보여줘

GET과 똑같지만 본문(body) 없이 헤더 정보만 가져와요. 파일 크기나 수정 시간만 확인하고 싶을 때 유용해요.

```http title="파일 정보만 확인하기"
HEAD /api/files/large-video.mp4
```

```http title="응답 (헤더만)"
HTTP/1.1 200 OK
Content-Length: 104857600  // [!code highlight]
Content-Type: video/mp4
Last-Modified: Wed, 15 May 2024 10:30:00 GMT
```

**언제 사용하나요?**
- 파일 크기 확인: `HEAD /api/files/video.mp4`
- 리소스 존재 여부 확인: `HEAD /api/users/123`
- 캐시 유효성 검사: Last-Modified 헤더 확인

**실무 활용 예시**
- 대용량 파일 다운로드 전 크기 확인
- CDN 캐시 상태 체크
- API 헬스체크 (가벼운 확인)

✅ **Safe** - 서버 상태를 변경하지 않아요  
✅ **Idempotent** - 몇 번을 호출해도 같은 결과  
✅ **Cacheable** - 헤더 정보를 캐시할 수 있어요

## 7. OPTIONS: 어떤 메서드를 써도 될까?

서버가 어떤 HTTP 메서드를 지원하는지 미리 확인할 때 사용해요. 주로 CORS(Cross-Origin Resource Sharing) 에서 자동으로 호출돼요.

```http title="API 지원 메서드 확인"
OPTIONS /api/users
```

```http title="응답 예시"
HTTP/1.1 200 OK
Allow: GET, POST, PUT, DELETE  // [!code highlight]
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

**언제 사용하나요?**
- **CORS Preflight**: 브라우저가 자동으로 보내는 사전 확인 요청
- API 지원 메서드 확인: `OPTIONS /api/users`
- 서버 기능 탐색: 어떤 기능을 지원하는지 확인

**실무에서는**
- 대부분 브라우저가 자동으로 처리해요
- 프론트엔드 개발 시 CORS 에러의 원인이 되기도 해요
- 서버에서 적절한 CORS 헤더 설정이 중요해요

✅ **Safe** - 서버 상태를 변경하지 않아요  
✅ **Idempotent** - 몇 번을 호출해도 같은 결과  
❌ **Cacheable** - 보통 캐시하지 않아요

![웹 브라우저에서 OPTIONS 메서드 요청을 통해 CORS 정책을 확인하는 과정을 보여주는 개발자 도구 네트워크 탭 스크린샷](/images/http-request-methods/options-method.webp)

## 8. CONNECT: 터널을 뚫어줘

프록시 서버를 통해 다른 서버와 직접 연결(터널)을 만들 때 사용해요. 주로 HTTPS 프록시에서 사용돼요.

```http title="HTTPS 프록시 터널 생성"
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
```

**언제 사용하나요?**
- **HTTPS 프록시**: 암호화된 연결을 프록시 서버를 통해 전달
- **터널링**: 프록시를 거쳐 다른 프로토콜 사용
- **방화벽 우회**: 기업 네트워크에서 외부 접속

**실무에서는**
- 일반적인 웹 개발에서는 거의 사용하지 않아요
- 브라우저가 내부적으로 처리해요
- 네트워크 인프라 구축 시에나 필요해요

❌ **Safe** - 연결 상태를 변경해요  
❌ **Idempotent** - 연결은 상태를 가져요  
❌ **Cacheable** - 연결은 캐시할 수 없어요

## 9. TRACE: 내 요청이 어떻게 보이는지 알려줘

서버가 받은 요청을 그대로 돌려보내는 디버깅용 메서드예요. 프록시를 거치면서 요청이 어떻게 변경되는지 확인할 수 있어요.

```http title="TRACE 요청 예시"
TRACE /api/test HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
```

```http title="서버 응답 (요청을 그대로 반환)"
HTTP/1.1 200 OK
Content-Type: message/http

TRACE /api/test HTTP/1.1  // [!code highlight]
Host: example.com         // [!code highlight]
User-Agent: Mozilla/5.0   // [!code highlight]
```

**언제 사용하나요?**
- **디버깅**: 프록시를 거치면서 헤더가 어떻게 변경되는지 확인
- **네트워크 진단**: 요청 경로 추적
- **개발 도구**: HTTP 요청 분석

<Callout type="warning">
**보안 위험 주의!**

TRACE 메서드는 보안상 위험할 수 있어요:
- 인증 토큰이나 쿠키가 노출될 수 있어요
- XST (Cross-Site Tracing) 공격에 악용될 수 있어요
- 대부분의 웹 서버에서 기본적으로 비활성화되어 있어요

실무에서는 거의 사용하지 않아요!
</Callout>

✅ **Safe** - 서버 상태를 변경하지 않아요 (하지만 보안 위험)  
✅ **Idempotent** - 몇 번을 호출해도 같은 결과  
❌ **Cacheable** - 캐시하지 않아요

## 실무에서 HTTP 메서드 선택하기

API를 설계할 때 어떤 메서드를 선택해야 할지 헷갈릴 때가 있어요. 이런 가이드라인을 따라보세요:

<Steps>

### 데이터를 가져오고 싶을 때
- **단순 조회**: GET 사용
- **헤더만 필요**: HEAD 사용
- **복잡한 검색 조건**: POST도 고려 (URL 길이 제한 때문)

### 데이터를 만들고 싶을 때
- **새 리소스 생성**: POST 사용
- **특정 위치에 생성**: PUT 사용 (URI를 미리 알고 있을 때)

### 데이터를 수정하고 싶을 때
- **전체 교체**: PUT 사용 (모든 필드를 보낼 때)
- **부분 수정**: PATCH 사용 (일부 필드만 보낼 때)

### 데이터를 삭제하고 싶을 때
- **삭제**: DELETE 사용
- **실제로는 상태 변경**: PATCH로 deleted: true 설정도 고려

### 기타 상황
- **API 지원 확인**: OPTIONS 사용 (보통 브라우저가 자동 처리)
- **디버깅**: TRACE 사용 (보안 위험으로 권장하지 않음)

</Steps>

## 마치며

HTTP 메서드를 올바르게 사용하면:
- API가 더 직관적이게 돼요
- 캐시 최적화가 쉬워져요
- 보안이 향상돼요
- 개발자 간 소통이 명확해져요

실무에서는 GET, POST, PUT, PATCH, DELETE 정도만 잘 알아도 충분해요. 나머지는 필요할 때 찾아보면 됩니다!

## 참고

- [HTTP request methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
- [Is it possible to cache POST methods in HTTP?](https://stackoverflow.com/questions/626057/is-it-possible-to-cache-post-methods-in-http)
